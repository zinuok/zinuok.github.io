{{/* =========================
   Authors (keep it simple)
   ========================= */}}

{{ $authors := .Params.authors }}

{{ if $authors }}
<div class="authors">
  {{ range $i, $a := $authors }}
    <span class="author">{{ $a | markdownify }}</span>{{ if lt $i (sub (len $authors) 1) }}, {{ end }}
  {{ end }}
</div>
{{ end }}

{{/* =========================
   Equal contribution legend (create)
   ========================= */}}

{{ $has_equal := false }}
{{ with .Params.author_notes }}
  {{ range . }}
    {{ if eq . "Equal contribution" }}{{ $has_equal = true }}{{ end }}
  {{ end }}
{{ end }}

{{ if $has_equal }}
<div id="equal-contrib-legend" style="font-size:0.85em; margin-top:0.25em; line-height:1.3;">
  (* Equal contribution)
</div>
{{ end }}

<script>
document.addEventListener('DOMContentLoaded', function () {
  // ---- move legend after publication line ----
  const legend = document.getElementById('equal-contrib-legend');
  if (legend) {
    const pub =
      document.querySelector('.pub-publication') ||
      document.querySelector('[class*="pub-publication"]');

    if (pub && pub.parentNode) {
      pub.insertAdjacentElement('afterend', legend);
    }
  }

  // ---- remove leading "(YYYY)." (often rendered as its own node) ----
  // 1) "(2025)." 처럼 '연도만' 들어있는 작은 요소 삭제
  document.querySelectorAll('span, strong, em, p, div').forEach(el => {
    const t = (el.textContent || '').trim();
    if (/^\(\d{4}\)\.\s*$/.test(t)) {
      el.remove();
    }
  });

  // 2) 문장 시작이 "(2025). " 형태면 접두사만 제거
  document.querySelectorAll('p, div, span').forEach(el => {
    const t = (el.textContent || '').trim();
    if (/^\(\d{4}\)\.\s+/.test(t)) {
      el.textContent = t.replace(/^\(\d{4}\)\.\s+/, '');
    }
  });
});
</script>
